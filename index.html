<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HH â€“ Browser PDF Compiler (No Upload)</title>
  <meta name="description" content="Merge/compile PDFs by filename rules. 100% in your browser. No uploads. No storage." />
  <style>
    :root { --bg:#0b0f12; --panel:#12181d; --text:#e6eef6; --muted:#8aa0b5; --brand:#26a269; --accent:#3d7bfd; }
    * { box-sizing: border-box; }
    html, body { margin:0; padding:0; background:var(--bg); color:var(--text); font:16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    header { padding:24px 20px; background: linear-gradient(180deg, rgba(38,162,105,0.15), rgba(0,0,0,0)); border-bottom:1px solid #1c232b; }
    h1 { margin:0 0 6px; font-size:22px; letter-spacing:0.2px; }
    .sub { color:var(--muted); font-size:14px; }
    main { max-width:1100px; margin:0 auto; padding:24px 20px 80px; }
    .panel { background:var(--panel); border:1px solid #1c232b; border-radius:14px; padding:18px; margin:14px 0; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    label.btn, button.btn { background:#0e141a; border:1px solid #222c36; color:var(--text); padding:10px 14px; border-radius:10px; cursor:pointer; transition: .15s ease; font-weight:600; }
    button.btn.primary { background:var(--brand); border-color:#1e8052; color:#07130d; }
    button.btn.ghost { background:transparent; }
    button.btn:disabled { opacity:.5; cursor:not-allowed; }
    input[type="file"] { display:none; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#0f141a; border:1px solid #1b242d; border-radius:6px; padding:2px 6px; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:14px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:#cfe3f8; }
    .small { font-size:13px; color:var(--muted); }
    ul.inline { list-style:none; margin:8px 0 0; padding:0; display:flex; gap:10px; flex-wrap:wrap; }
    .pill { border:1px solid #2a3440; background:#0f1417; padding:6px 8px; border-radius:999px; font-size:12px; }
    .ok { color:#6dd27c; }
    .miss { color:#ff7272; }
    .log { background:#0f1417; border:1px solid #1b2430; border-radius:8px; padding:10px; height:200px; overflow:auto; }
    details { border:1px solid #1c232b; border-radius:10px; padding:8px 10px; background:#0f1417; }
    details > summary { cursor:pointer; font-weight:600; }
    .right { margin-left:auto; }
    .muted { color:var(--muted); }
    .badge { font-size:12px; padding:4px 8px; border-radius:999px; border:1px solid #2a3440; background:#0f1417; }
    a { color:var(--accent); text-decoration:none; }
  </style>
</head>
<body>
  <header>
    <h1>HH â€“ Browser PDF Compiler <span class="small">(No Upload)</span></h1>
    <div class="sub">Compiles PDFs by filename rules, entirely in your browser. Nothing is uploaded or stored.</div>
  </header>

  <main>
    <div class="panel">
      <div class="row">
        <label class="btn" for="pick">ğŸ“ Select Folder of PDFs</label>
        <input id="pick" type="file" webkitdirectory directory multiple accept="application/pdf" />
        <button id="scanBtn" class="btn">ğŸ” Scan & Analyse</button>
        <button id="grantFs" class="btn">ğŸ—‚ï¸ Grant Local Folder Access</button>
        <span id="fsBadge" class="badge muted">Folder Write: OFF</span>
        <span id="selInfo" class="muted right"></span>
      </div>
    </div>

    <div class="panel grid">
      <div>
        <h3 style="margin:4px 0 10px;">Closing Docs â€“ Slots</h3>
        <div id="slots"></div>
      </div>
      <div>
        <h3 style="margin:4px 0 10px;">Actions</h3>
        <div class="row" style="margin-bottom:8px;">
          <button id="runAll" class="btn primary" disabled>ğŸš€ Run All (Closing â†’ Funding 1 â†’ Client Pkg â†’ ZIP)</button>
          <button id="buildClosing" class="btn" disabled>âš™ï¸ Build Closing Docs (PDF)</button>
          <button id="buildFunding1" class="btn" disabled>ğŸ“„ Build Funding Docs 1 (PDF)</button>
        </div>
        <div class="row">
          <button id="buildClientPkg" class="btn" disabled>ğŸ‘ª Build Client Closing Package (PDF)</button>
          <button id="zipFD2" class="btn" disabled>ğŸ—œï¸ Download â€œFunding Docs 2â€.zip</button>
        </div>
        <p class="small muted">All processing is inâ€‘memory. Files never leave your device. <b>Grant Local Folder Access</b> (Chrome/Edge) to autoâ€‘save outputs, create <i>Funding Docs 2</i>, and move used files. Otherwise, files will download as usual.</p>
      </div>
    </div>

    <details class="panel"><summary>Log</summary>
      <div id="log" class="log mono"></div>
    </details>
  </main>

  <!-- Vendor (place local copies in ./vendor) -->
  <script src="vendor/pdf-lib.min.js"></script>
  <script src="vendor/jszip.min.js"></script>

  <script>
  // ======= CONFIG mirrored from Python =======
  const CLOSING_ORDER = [
    "commitment only","kyc","idv","pep","mtg application","insurance","consent","cost of credit","form 10 only","form 10 to lender"
  ];
  const MULTI_INCLUDE_SLOTS = new Set(["kyc","pep","consent","insurance"]);
  const DISPLAY_NAMES = {
    "commitment only":"Commitment Only","kyc":"KYC","idv":"IDV","pep":"PEP","mtg application":"Mtg Application","insurance":"Insurance","consent":"Consent","cost of credit":"Cost of Borrowing","form 10 only":"Form 10 Only","form 10 to lender":"Form 10 to Lender",
  };
  const CLIENT_PKG_ORDER = ["thank you","amortization","commitment only","form 10 only","cost of credit"];
  const SYNONYMS = {
    "commitment only":["commit only","commitment"],
    "mtg application":["mortgage application","mtg app","mortgage app","application"],
    "idv":["idv","verification"],
    "cost of credit":["cob","cost of borrowing","disclosure"],
    "insurance":["prospr","mpp","manulife","sun life","sunlife","indem","assurant"],
    "form 10 only":["form 10","form10","broker compensation"],
    "form 10 to lender":["form 10 to lender","form10 to lender","compensation to lender"],
    "kyc":["know your client","know-your-client","client information"],
    "pep":["pep","politically exposed"],
    "consent":["consent","authorization","authorisation"],
    "thank you":["thank you","thank-you","thanks"],
    "amortization":["amortization","amortisation","amort sched","amort schedule"],
  };

  // ======= State =======
  let pickedFiles = []; // File[] from selection/drag
  let pickedMap = new Map(); // normalized name -> File[]
  let dirHandle = null; // File System Access API directory handle
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  const $ = (sel) => document.querySelector(sel);
  const log = (m) => { const el=$('#log'); el.textContent += m +"\n"; el.scrollTop = el.scrollHeight; };
  const norm = (s) => s.toLowerCase().replace(/[^a-z0-9]+/g,' ').trim();
  const natKey = (s) => s.toLowerCase().split(/(\d+)/).map(t=>/^\d+$/.test(t)?Number(t):t);

  // ======= FS Access helpers =======
  async function grantFolderAccess(){
    if(!('showDirectoryPicker' in window)){
      log('This browser does not support Local Folder Access. Use Chrome/Edge for write mode.');
      return;
    }
    try{
      dirHandle = await window.showDirectoryPicker();
      $('#fsBadge').textContent = 'Folder Write: ON (' + (dirHandle.name || 'selected') + ')';
      $('#fsBadge').classList.remove('muted');
      log('Folder access granted. Writes/moves will target: ' + (dirHandle.name || 'selected folder'));
    }catch(e){ log('Folder access cancelled.'); }
  }

  async function ensureDir(parent, name){
    return await parent.getDirectoryHandle(name, { create: true });
  }
  async function writeFile(parent, name, blob){
    const fileHandle = await parent.getFileHandle(name, { create: true });
    const w = await fileHandle.createWritable();
    await w.write(blob); await w.close();
  }
  async function readTopLevelPDFsFromFS(){
    // enumerate current top-level PDFs (excludes subfolders)
    const files = [];
    if(!dirHandle) return files;
    for await (const [name, handle] of dirHandle.entries()){
      if(handle.kind === 'file' && name.toLowerCase().endsWith('.pdf')){
        const f = await handle.getFile();
        files.push(f);
      }
    }
    // natural sort
    files.sort((a,b)=>{ const ak=natKey(a.name), bk=natKey(b.name); for(let i=0;i<Math.max(ak.length,bk.length);i++){ if(ak[i]==null) return -1; if(bk[i]==null) return 1; if(ak[i]<bk[i]) return -1; if(ak[i]>bk[i]) return 1; } return 0; });
    return files;
  }
  async function moveFileToFD2ByName(name){
    try{
      const fd2 = await ensureDir(dirHandle, 'Funding Docs 2');
      const srcHandle = await dirHandle.getFileHandle(name);
      const srcFile = await srcHandle.getFile();
      const buf = await srcFile.arrayBuffer();
      await writeFile(fd2, name, new Blob([buf], {type:'application/pdf'}));
      await dirHandle.removeEntry(name);
      log('Moved to Funding Docs 2: ' + name);
    }catch(e){ log('Move failed (skip if not in top-level): ' + name); }
  }

  // ======= Selection / Index =======
  function indexFiles(files){
    pickedMap.clear();
    const pdfs = [...files].filter(f=> f.name.toLowerCase().endsWith('.pdf'));
    pdfs.sort((a,b)=>{ const ak=natKey(a.name), bk=natKey(b.name); for(let i=0;i<Math.max(ak.length,bk.length);i++){ if(ak[i]==null) return -1; if(bk[i]==null) return 1; if(ak[i]<bk[i]) return -1; if(ak[i]>bk[i]) return 1; } return 0; });
    pickedFiles = pdfs;
    for(const f of pdfs){ const n = norm(f.name); if(!pickedMap.has(n)) pickedMap.set(n,[]); pickedMap.get(n).push(f); }
    $('#selInfo').textContent = `${pdfs.length} PDF(s) selected`;
    log(`Indexed ${pdfs.length} PDFs.`);
  }

  // ======= Matching =======
  function listCandidates(){
    const all = Array.from(pickedMap.values()).flat();
    const lowerCache = new Map(all.map(f=>[f, norm(f.name)]));
    const resUsed = []; const summary = []; const slotDocs = new Map(CLOSING_ORDER.map(s=>[s,[]]));

    for(const slot of CLOSING_ORDER){
      const keys = [slot, ...(SYNONYMS[slot]||[])].map(norm);
      let matches = all.filter(f => keys.some(k => lowerCache.get(f).includes(k)));
      const nameNorm = (f)=> lowerCache.get(f);
      if(slot === 'cost of credit'){
        const cobRe = /(?<![a-z])cob(?![a-z])|\bcost[\s_-]*of[\s_-]*(?:borrowing|credit)\b/i;
        matches = matches.filter(f=> cobRe.test(nameNorm(f)) && !/(form 10|form10|compensation|to lender)/i.test(nameNorm(f)) );
      }
      if(slot === 'form 10 only') matches = matches.filter(f=> !/to lender/i.test(nameNorm(f)) );

      if(MULTI_INCLUDE_SLOTS.has(slot)){
        const chosen = matches.sort((a,b)=> a.lastModified - b.lastModified);
        slotDocs.set(slot, chosen);
        resUsed.push(...chosen);
        chosen.forEach(m=> summary.push(`${DISPLAY_NAMES[slot]||slot}: ${m.name}`));
      } else {
        const chosen = matches.sort((a,b)=> a.lastModified - b.lastModified).slice(-1)[0];
        if(chosen){ slotDocs.set(slot, [chosen]); resUsed.push(chosen); summary.push(`${DISPLAY_NAMES[slot]||slot}: ${chosen.name}`); }
        else { summary.push(`${DISPLAY_NAMES[slot]||slot}: MISSING`); }
      }
    }
    return {slotDocs, resUsed, summary};
  }

  function renderSlots(view){
    const root = $('#slots'); root.innerHTML = '';
    const ul = document.createElement('ul'); ul.className = 'inline';
    for(const slot of CLOSING_ORDER){
      const arr = view.slotDocs.get(slot) || [];
      const li = document.createElement('li'); li.className='pill';
      const ok = arr.length>0; li.innerHTML = `<span class="${ok? 'ok':'miss'}">${ok? 'âœ”':'âœ–'}</span> <b>${DISPLAY_NAMES[slot]||slot}</b>${ ok? ` Â· ${arr.length} file(s)` : ''}`;
      ul.appendChild(li);
    }
    root.appendChild(ul);
  }

  // ======= PDF helpers (encryption tolerant) =======
  async function mergePDFs(parts, summaryBlob, outName, writeToFolder=false){
    const { PDFDocument } = PDFLib;

    async function loadPdf(bytes){
      try { return await PDFDocument.load(bytes); }
      catch(e){ return await PDFDocument.load(bytes, { ignoreEncryption: true }); }
    }

    try {
      const out = await PDFDocument.create();

      if(summaryBlob){
        const sumBytes = await summaryBlob.arrayBuffer();
        const sumDoc = await loadPdf(sumBytes);
        const pages = await out.copyPages(sumDoc, sumDoc.getPageIndices());
        pages.forEach(p=> out.addPage(p));
      }

      for(const file of parts){
        try{
          const bytes = await file.arrayBuffer();
          const src = await loadPdf(bytes);
          const pages = await out.copyPages(src, src.getPageIndices());
          pages.forEach(p=> out.addPage(p));
        }catch(e){ log(`Merge warning: skipped encrypted or unreadable file â†’ ${file.name}`); }
      }

      const outBytes = await out.save();
      const outBlob = new Blob([outBytes], {type:'application/pdf'});
      if(writeToFolder && dirHandle){
        await writeFile(dirHandle, outName, outBlob);
        log('Saved directly: ' + outName);
      } else {
        downloadBlob(outBlob, outName);
      }
    } catch (e) {
      console.error(e); log('Merge error: ' + (e?.message || e));
      throw e;
    }
  }

  function downloadBlob(blob, name){
    const a = document.createElement('a');
    const url = URL.createObjectURL(blob);
    a.href = url; a.download = name; document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 1500);
  }

  async function makeSummaryPDF(title, lines){
    const { PDFDocument, StandardFonts, rgb } = PDFLib;
    const doc = await PDFDocument.create();
    const page = doc.addPage([612, 792]); // Letter
    const font = await doc.embedFont(StandardFonts.Helvetica);

    page.drawText(title, { x:54, y:740, size:20, font, color: rgb(0.9,0.97,1) });
    let y = 710;
    for(const line of lines){
      const isMissing = /MISSING$/.test(line);
      page.drawText(line, { x:54, y, size:12, font, color: isMissing? rgb(1,0.45,0.45): rgb(0.8,0.9,1) });
      y -= 16; if(y<60){ y = 740; doc.addPage([612,792]); }
    }
    const bytes = await doc.save();
    return new Blob([bytes], {type:'application/pdf'});
  }

  function folderPrefix(){
    const f = pickedFiles[0]; if(!f) return 'Client';
    const segs = (f.webkitRelativePath||f.name).split('/').filter(Boolean);
    return segs.length? segs[0] : 'Client';
  }

  // ======= Build steps =======
  async function buildClosing(){
    log('Building Closing Docs...');
    const v = listCandidates();
    const summaryBlob = await makeSummaryPDF('Closing Docs', v.summary);
    const parts = CLOSING_ORDER.flatMap(slot => v.slotDocs.get(slot)||[]);
    const outName = folderPrefix()+" - Closing Docs.pdf";

    await mergePDFs(parts, summaryBlob, outName, !!dirHandle);

    // In write mode, also move used files and write summary to FD2
    if(dirHandle){
      const fd2 = await ensureDir(dirHandle, 'Funding Docs 2');
      // write the summary directly into FD2
      await writeFile(fd2, `_summary_closing_docs.pdf`, summaryBlob);
      for(const f of v.resUsed){ await moveFileToFD2ByName(f.name); }
    }
    log('Closing Docs ready.');
  }

  async function buildFunding1(){
    try {
      log('Building Funding Docs 1...');
      let files;
      if(dirHandle){
        // live top-level scan from disk
        const exclude = new Set([
          (folderPrefix()+" - Closing Docs.pdf").toLowerCase(),
          (folderPrefix()+" - Funding Docs 1.pdf").toLowerCase(),
          (folderPrefix()+" - Closing Package (for Client).pdf").toLowerCase()
        ]);
        const all = await readTopLevelPDFsFromFS();
        files = all.filter(f=> !f.name.startsWith('_summary') && !exclude.has(f.name.toLowerCase()));
      } else {
        // prior behavior
        files = pickedFiles.filter(f=> !/^_summary/i.test(f.name));
      }

      log(`Funding1: ${files.length} file(s) to merge.`);
      const names = files.map(f=>f.name).sort();
      const summaryBlob = await makeSummaryPDF('Funding Docs', names);
      const outName = folderPrefix()+" - Funding Docs 1.pdf";
      await mergePDFs(files, summaryBlob, outName, !!dirHandle);

      if(dirHandle){
        const fd2 = await ensureDir(dirHandle, 'Funding Docs 2');
        await writeFile(fd2, `_summary_funding_docs.pdf`, summaryBlob);
        // move all files included in Funding Docs 1 to FD2
        for(const f of files){ await moveFileToFD2ByName(f.name); }
      }
      log('Funding Docs 1 ready.');
    } catch (e) {
      console.error(e); log('Error building Funding Docs 1: ' + (e?.message || e));
    }
  }

  async function buildClientPkg(){
    log('Building Client Closing Package...');
    const all = Array.from(pickedMap.values()).flat();
    const lower = new Map(all.map(f=>[f, norm(f.name)]));
    const pickOne = (slot, matches)=> matches.sort((a,b)=> a.lastModified - b.lastModified).slice(-1)[0];

    const parts = []; const lines = [];
    const nameNorm = f => lower.get(f);

    let chosenThankYou = null; let chosenAmort = null;

    for(const slot of CLIENT_PKG_ORDER){
      const label = DISPLAY_NAMES[slot] || slot.replace(/\b\w/g,c=>c.toUpperCase());
      const keys = [slot, ...(SYNONYMS[slot]||[])].map(norm);
      let matches = all.filter(f => keys.some(k => nameNorm(f).includes(k)));
      if(slot==='cost of credit'){
        const cobRe = /(?<![a-z])cob(?![a-z])|\bcost[\s_-]*of[\s_-]*(?:borrowing|credit)\b/i;
        matches = matches.filter(f=> cobRe.test(nameNorm(f)) && !/(form 10|form10|compensation|to lender)/i.test(nameNorm(f)) );
      }
      if(slot==='form 10 only') matches = matches.filter(f=> !/to lender/i.test(nameNorm(f)) );

      const chosen = pickOne(slot, matches);
      if(chosen){
        parts.push(chosen); lines.push(`${label}: ${chosen.name}`);
        if(slot==='thank you') chosenThankYou = chosen;
        if(slot==='amortization') chosenAmort = chosen;
      } else { lines.push(`${label}: MISSING`); }
    }

    const cover = await makeSummaryPDF('Client Closing Package', lines);
    const outName = folderPrefix()+" - Closing Package (for Client).pdf";
    await mergePDFs(parts, cover, outName, !!dirHandle);

    if(dirHandle){
      const fd2 = await ensureDir(dirHandle, 'Funding Docs 2');
      await writeFile(fd2, `_summary_client_package.pdf`, cover);
      for(const f of [chosenThankYou, chosenAmort]){ if(f) await moveFileToFD2ByName(f.name); }
    }
    log('Client Closing Package ready.');
  }

  async function downloadFD2Zip(){
    try {
      log('Preparing Funding Docs 2.zip ...');
      const zip = new JSZip();
      if(dirHandle){
        // Walk FD2 from disk and zip
        const fd2 = await ensureDir(dirHandle, 'Funding Docs 2');
        for await (const [name, handle] of fd2.entries()){
          if(handle.kind==='file'){
            const file = await handle.getFile();
            const buf = await file.arrayBuffer();
            zip.file(name, buf);
          }
        }
        const blob = await zip.generateAsync({type:'blob'});
        const outName = folderPrefix()+" - Funding Docs 2.zip";
        await writeFile(dirHandle, outName, blob);
        log('Saved directly: ' + outName);
      } else {
        // Prior behavior: zip used files from analysis
        const v = listCandidates();
        const dir = zip.folder('Funding Docs 2');
        const usedSet = new Set(v.resUsed);
        for(const f of usedSet){ const buf = await f.arrayBuffer(); dir.file(f.name, buf); }
        const blob = await zip.generateAsync({type:'blob'});
        downloadBlob(blob, folderPrefix()+" - Funding Docs 2.zip");
        log('ZIP ready (download).');
      }
    } catch(e){ console.error(e); log('ZIP error: ' + (e?.message || e)); }
  }

  async function runAll(){
    try {
      if(pickedFiles.length===0){ log('No PDFs selected.'); return; }
      log('Running all steps...');
      await buildClosing(); await sleep(400);
      await buildFunding1(); await sleep(400);
      await buildClientPkg(); await sleep(400);
      await downloadFD2Zip();
      log('All steps completed. If multiple files didn\'t appear, allow multiple downloads for this site.');
    } catch(e) { console.error(e); log('Run All error: ' + (e?.message || e)); }
  }

  // ======= UI Events =======
  $('#pick').addEventListener('change', (e)=>{ indexFiles(e.target.files); const v=listCandidates(); renderSlots(v); setActionsEnabled(pickedFiles.length>0); });
  $('#scanBtn').addEventListener('click', ()=>{ if(pickedFiles.length===0) return; const v=listCandidates(); renderSlots(v); log('Analysis updated.'); });
  $('#grantFs').addEventListener('click', grantFolderAccess);
  $('#buildClosing').addEventListener('click', buildClosing);
  $('#buildFunding1').addEventListener('click', buildFunding1);
  $('#buildClientPkg').addEventListener('click', buildClientPkg);
  $('#zipFD2').addEventListener('click', downloadFD2Zip);
  $('#runAll').addEventListener('click', runAll);

  function setActionsEnabled(enabled){
    ['buildClosing','buildFunding1','buildClientPkg','zipFD2','runAll'].forEach(id=>{ const b=$('#'+id); if(b) b.disabled = !enabled; });
  }

  // Drag & drop folder support (Chrome-based)
  window.addEventListener('dragover', e=>{ e.preventDefault(); });
  window.addEventListener('drop', e=>{
    e.preventDefault();
    const items = e.dataTransfer.items; if(!items) return;
    const entries = [];
    for(const it of items){ const entry = it.webkitGetAsEntry?.(); if(entry) entries.push(entry); }
    const promises = entries.map(entry => new Promise(res=>{
      const acc = [];
      const walk = (ent, path='')=>{
        if(ent.isFile){ ent.file(f=>{ f.webkitRelativePath = path + f.name; acc.push(f); }, ()=>{}); }
        else if(ent.isDirectory){ const reader = ent.createReader(); reader.readEntries(ents=>{ ents.forEach(ch=> walk(ch, path + ent.name + '/')); }, ()=>{}); }
      };
      walk(entry); setTimeout(()=> res(acc), 300);
    }));
    Promise.all(promises).then(groups=>{ const all = groups.flat(); indexFiles(all); const v=listCandidates(); renderSlots(v); setActionsEnabled(pickedFiles.length>0); });
  });
  </script>
</body>
</html>
