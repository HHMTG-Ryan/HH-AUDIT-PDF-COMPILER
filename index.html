<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>HH â€“ Browser PDF Compiler (No Upload)</title>
  <meta name="description" content="Merge/compile PDFs by filename rules. 100% in your browser. No uploads. No storage." />
  <style>
    :root { --bg:#0b0f12; --panel:#12181d; --text:#e6eef6; --muted:#8aa0b5; --brand:#26a269; --accent:#3d7bfd; }
    * { box-sizing: border-box; }
    html, body { margin:0; padding:0; background:var(--bg); color:var(--text); font:16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji"; }
    header { padding:24px 20px; background: linear-gradient(180deg, rgba(38,162,105,0.15), rgba(0,0,0,0)); border-bottom:1px solid #1c232b; }
    h1 { margin:0 0 6px; font-size:22px; letter-spacing:0.2px; }
    .sub { color:var(--muted); font-size:14px; }
    main { max-width:1000px; margin:0 auto; padding:24px 20px 80px; }
    .panel { background:var(--panel); border:1px solid #1c232b; border-radius:14px; padding:18px; margin:14px 0; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    label.btn, button.btn { background:#0e141a; border:1px solid #222c36; color:var(--text); padding:10px 14px; border-radius:10px; cursor:pointer; transition: .15s ease; font-weight:600; }
    button.btn.primary { background:var(--brand); border-color:#1e8052; color:#07130d; }
    button.btn.ghost { background:transparent; }
    button.btn:disabled { opacity:.5; cursor:not-allowed; }
    input[type="file"] { display:none; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#0f141a; border:1px solid #1b242d; border-radius:6px; padding:2px 6px; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:14px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:#cfe3f8; }
    .small { font-size:13px; color:var(--muted); }
    ul.inline { list-style:none; margin:8px 0 0; padding:0; display:flex; gap:10px; flex-wrap:wrap; }
    .pill { border:1px solid #2a3440; background:#0f1417; padding:6px 8px; border-radius:999px; font-size:12px; }
    .ok { color:#6dd27c; }
    .miss { color:#ff7272; }
    .log { background:#0f1417; border:1px solid #1b2430; border-radius:8px; padding:10px; height:180px; overflow:auto; }
    details { border:1px solid #1c232b; border-radius:10px; padding:8px 10px; background:#0f1417; }
    details > summary { cursor:pointer; font-weight:600; }
    .right { margin-left:auto; }
    .muted { color:var(--muted); }
    a { color:var(--accent); text-decoration:none; }
  </style>
</head>
<body>
  <header>
    <h1>HH â€“ Browser PDF Compiler <span class="small">(No Upload)</span></h1>
    <div class="sub">Compiles PDFs by filename rules, entirely in your browser. Nothing is uploaded or stored.</div>
  </header>

  <main>
    <div class="panel">
      <div class="row">
        <label class="btn" for="pick">ğŸ“ Select Folder of PDFs</label>
        <input id="pick" type="file" webkitdirectory directory multiple accept="application/pdf" />
        <button id="scanBtn" class="btn">ğŸ” Scan & Analyse</button>
        <span id="selInfo" class="muted"></span>
        <span class="right small">Tip: drag a folder here â†’ <span class="kbd">window</span></span>
      </div>
    </div>

    <div class="panel grid">
      <div>
        <h3 style="margin:4px 0 10px;">Closing Docs â€“ Slots</h3>
        <div id="slots"></div>
      </div>
      <div>
        <h3 style="margin:4px 0 10px;">Actions</h3>
        <div class="row" style="margin-bottom:8px;">
          <button id="buildClosing" class="btn primary" disabled>âš™ï¸ Build Closing Docs (PDF)</button>
          <button id="buildFunding1" class="btn" disabled>ğŸ“„ Build Funding Docs 1 (PDF)</button>
        </div>
        <div class="row">
          <button id="buildClientPkg" class="btn" disabled>ğŸ‘ª Build Client Closing Package (PDF)</button>
          <button id="zipFD2" class="btn" disabled>ğŸ—œï¸ Download â€œFunding Docs 2â€.zip</button>
        </div>
        <p class="small muted">All processing is inâ€‘memory. Files never leave your device. Close the tab to clear memory.</p>
      </div>
    </div>

    <details class="panel"><summary>Log</summary>
      <div id="log" class="log mono"></div>
    </details>
  </main>

  <!-- Vendor (place these files in ./vendor and keep them local for no-network operation) -->
  <script src="vendor/pdf-lib.min.js"></script>
  <script src="vendor/jszip.min.js"></script>

  <script>
  // ======= CONFIG mirrored from Python =======
  const CLOSING_ORDER = [
    "commitment only","kyc","idv","pep","mtg application","insurance","consent","cost of credit","form 10 only","form 10 to lender"
  ];
  const MULTI_INCLUDE_SLOTS = new Set(["kyc","pep","consent","insurance"]);
  const DISPLAY_NAMES = {
    "commitment only":"Commitment Only","kyc":"KYC","idv":"IDV","pep":"PEP","mtg application":"Mtg Application","insurance":"Insurance","consent":"Consent","cost of credit":"Cost of Borrowing","form 10 only":"Form 10 Only","form 10 to lender":"Form 10 to Lender",
  };
  const CLIENT_PKG_ORDER = ["thank you","amortization","commitment only","form 10 only","cost of credit"];
  const SYNONYMS = {
    "commitment only":["commit only","commitment"],
    "mtg application":["mortgage application","mtg app","mortgage app","application"],
    "idv":["idv","verification"],
    "cost of credit":["cob","cost of borrowing","disclosure"],
    "insurance":["prospr","mpp","manulife","sun life","sunlife","indem","assurant"],
    "form 10 only":["form 10","form10","broker compensation"],
    "form 10 to lender":["form 10 to lender","form10 to lender","compensation to lender"],
    "kyc":["know your client","know-your-client","client information"],
    "pep":["pep","politically exposed"],
    "consent":["consent","authorization","authorisation"],
    "thank you":["thank you","thank-you","thanks"],
    "amortization":["amortization","amortisation","amort sched","amort schedule"],
  };

  // ======= State =======
  let pickedFiles = []; // File[]
  let pickedMap = new Map(); // normalized name -> File[] (keep all so we can pick latest)

  const $ = (sel) => document.querySelector(sel);
  const log = (m) => { const el=$('#log'); el.textContent += m +"\n"; el.scrollTop = el.scrollHeight; };
  const norm = (s) => s.toLowerCase().replace(/[^a-z0-9]+/g,' ').trim();
  const natKey = (s) => s.toLowerCase().split(/(\d+)/).map(t=>t.match(/^\d+$/)?Number(t):t);

  function indexFiles(files){
    pickedMap.clear();
    const pdfs = [...files].filter(f=>f.type==="application/pdf" || f.name.toLowerCase().endsWith('.pdf'));
    pdfs.sort((a,b)=>{ const ak=natKey(a.name), bk=natKey(b.name); for(let i=0;i<Math.max(ak.length,bk.length);i++){ if(ak[i]==null) return -1; if(bk[i]==null) return 1; if(ak[i]<bk[i]) return -1; if(ak[i]>bk[i]) return 1; } return 0; });
    pickedFiles = pdfs;
    for(const f of pdfs){ const n = norm(f.name); if(!pickedMap.has(n)) pickedMap.set(n,[]); pickedMap.get(n).push(f); }
    $('#selInfo').textContent = `${pdfs.length} PDF(s) selected`;
    log(`Indexed ${pdfs.length} PDFs.`);
  }

  function listCandidates(){
    // Dedup by name; most recent (by lastModified) for single slots
    const all = Array.from(pickedMap.values()).flat();
    const lowerCache = new Map(all.map(f=>[f, norm(f.name)]));

    const resUsed = []; // File[]
    const summary = []; // strings
    const slotDocs = new Map(CLOSING_ORDER.map(s=>[s,[]]));

    for(const slot of CLOSING_ORDER){
      const keys = [slot, ...(SYNONYMS[slot]||[])].map(norm);
      let matches = all.filter(f => keys.some(k => lowerCache.get(f).includes(k)));

      const nameNorm = (f)=> lowerCache.get(f);
      if(slot === 'cost of credit'){
        const cobRe = /(?<![a-z])cob(?![a-z])|\bcost[\s_-]*of[\s_-]*(?:borrowing|credit)\b/i;
        matches = matches.filter(f=> cobRe.test(nameNorm(f)) && !/(form 10|form10|compensation|to lender)/i.test(nameNorm(f)) );
      }
      if(slot === 'form 10 only'){
        matches = matches.filter(f=> !/to lender/i.test(nameNorm(f)) );
      }

      if(MULTI_INCLUDE_SLOTS.has(slot)){
        const chosen = matches.sort((a,b)=> a.lastModified - b.lastModified);
        slotDocs.set(slot, chosen);
        resUsed.push(...chosen);
        chosen.forEach(m=> summary.push(`${DISPLAY_NAMES[slot]||slot}: ${m.name}`));
      } else {
        const chosen = matches.sort((a,b)=> a.lastModified - b.lastModified).slice(-1)[0];
        if(chosen){
          slotDocs.set(slot, [chosen]);
          resUsed.push(chosen);
          summary.push(`${DISPLAY_NAMES[slot]||slot}: ${chosen.name}`);
        } else {
          summary.push(`${DISPLAY_NAMES[slot]||slot}: MISSING`);
        }
      }
    }
    return {slotDocs, resUsed, summary};
  }

  function renderSlots(view){
    const root = $('#slots');
    root.innerHTML = '';
    const ul = document.createElement('ul'); ul.className = 'inline';
    for(const slot of CLOSING_ORDER){
      const arr = view.slotDocs.get(slot) || [];
      const li = document.createElement('li'); li.className='pill';
      const ok = arr.length>0; li.innerHTML = `<span class="${ok? 'ok':'miss'}">${ok? 'âœ”':'âœ–'}</span> <b>${DISPLAY_NAMES[slot]||slot}</b>${ ok? ` Â· ${arr.length} file(s)` : ''}`;
      ul.appendChild(li);
    }
    root.appendChild(ul);

    // Enable actions if we have any PDFs
    const has = pickedFiles.length>0;
    $('#buildClosing').disabled = !has;
    $('#buildFunding1').disabled = !has;
    $('#buildClientPkg').disabled = !has;
    $('#zipFD2').disabled = !has;
  }

  async function makeSummaryPDF(title, lines){
    const { PDFDocument, StandardFonts, rgb } = PDFLib;
    const doc = await PDFDocument.create();
    const page = doc.addPage([612, 792]); // Letter
    const font = await doc.embedFont(StandardFonts.Helvetica);

    page.drawText(title, { x:54, y:740, size:20, font, color: rgb(0.9,0.97,1) });
    let y = 710;
    for(const line of lines){
      const isMissing = /MISSING$/.test(line);
      page.drawText(line, { x:54, y, size:12, font, color: isMissing? rgb(1,0.45,0.45): rgb(0.8,0.9,1) });
      y -= 16; if(y<60){ y = 740; doc.addPage([612,792]); }
    }
    const bytes = await doc.save();
    return new Blob([bytes], {type:'application/pdf'});
  }

  async function mergePDFs(parts, summaryBlob, outName){
    const { PDFDocument } = PDFLib;
    const out = await PDFDocument.create();

    if(summaryBlob){
      const sumBytes = await summaryBlob.arrayBuffer();
      const sumDoc = await PDFDocument.load(sumBytes);
      const pages = await out.copyPages(sumDoc, sumDoc.getPageIndices());
      pages.forEach(p=> out.addPage(p));
    }

    for(const file of parts){
      const bytes = await file.arrayBuffer();
      const src = await PDFDocument.load(bytes);
      const pages = await out.copyPages(src, src.getPageIndices());
      pages.forEach(p=> out.addPage(p));
    }

    const outBytes = await out.save();
    downloadBlob(new Blob([outBytes], {type:'application/pdf'}), outName);
  }

  function downloadBlob(blob, name){
    const a = document.createElement('a');
    const url = URL.createObjectURL(blob);
    a.href = url; a.download = name; document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
  }

  async function buildClosing(){
    log('Building Closing Docs...');
    const v = listCandidates();
    const summaryBlob = await makeSummaryPDF('Closing Docs', v.summary);
    const parts = CLOSING_ORDER.flatMap(slot => v.slotDocs.get(slot)||[]);
    await mergePDFs(parts, summaryBlob, folderPrefix()+" - Closing Docs.pdf");
    log('Closing Docs ready.');
  }

  async function buildFunding1(){
    log('Building Funding Docs 1...');
    // All PDFs except ones we generate on the fly (we only see picked ones)
    const files = pickedFiles.filter(f=> !/^_summary/i.test(f.name));
    const names = files.map(f=>f.name).sort();
    const summaryBlob = await makeSummaryPDF('Funding Docs', names);
    await mergePDFs(files, summaryBlob, folderPrefix()+" - Funding Docs 1.pdf");
    log('Funding Docs 1 ready.');
  }

  async function buildClientPkg(){
    log('Building Client Closing Package...');
    const all = Array.from(pickedMap.values()).flat();
    const lower = new Map(all.map(f=>[f, norm(f.name)]));
    const pickOne = (slot, matches)=> matches.sort((a,b)=> a.lastModified - b.lastModified).slice(-1)[0];

    const parts = [];
    const lines = [];
    const nameNorm = f => lower.get(f);

    for(const slot of CLIENT_PKG_ORDER){
      const label = DISPLAY_NAMES[slot] || slot.replace(/\b\w/g,c=>c.toUpperCase());
      const keys = [slot, ...(SYNONYMS[slot]||[])].map(norm);
      let matches = all.filter(f => keys.some(k => nameNorm(f).includes(k)));
      if(slot==='cost of credit'){
        const cobRe = /(?<![a-z])cob(?![a-z])|\bcost[\s_-]*of[\s_-]*(?:borrowing|credit)\b/i;
        matches = matches.filter(f=> cobRe.test(nameNorm(f)) && !/(form 10|form10|compensation|to lender)/i.test(nameNorm(f)) );
      }
      if(slot==='form 10 only') matches = matches.filter(f=> !/to lender/i.test(nameNorm(f)) );

      const chosen = pickOne(slot, matches);
      if(chosen){ parts.push(chosen); lines.push(`${label}: ${chosen.name}`); }
      else { lines.push(`${label}: MISSING`); }
    }

    const cover = await makeSummaryPDF('Client Closing Package', lines);
    await mergePDFs(parts, cover, folderPrefix()+" - Closing Package (for Client).pdf");
    log('Client Closing Package ready.');
  }

  async function downloadFD2Zip(){
    log('Preparing Funding Docs 2.zip ...');
    const v = listCandidates();
    const zip = new JSZip();
    const dir = zip.folder('Funding Docs 2');
    // Move used + any summary (we only have used; summary pages are generated in build funcs)
    const usedSet = new Set(v.resUsed);
    for(const f of usedSet){ const buf = await f.arrayBuffer(); dir.file(f.name, buf); }
    const blob = await zip.generateAsync({type:'blob'});
    downloadBlob(blob, folderPrefix()+" - Funding Docs 2.zip");
    log('ZIP ready.');
  }

  function folderPrefix(){
    // Approximate using the top-level directory name from the first file's webkitRelativePath
    const f = pickedFiles[0];
    if(!f) return 'Client';
    const segs = (f.webkitRelativePath||f.name).split('/').filter(Boolean);
    return segs.length? segs[0] : 'Client';
  }

  // ======= UI Events =======
  $('#pick').addEventListener('change', (e)=>{ indexFiles(e.target.files); renderSlots(listCandidates()); });
  $('#scanBtn').addEventListener('click', ()=>{ if(pickedFiles.length===0) return; renderSlots(listCandidates()); log('Analysis updated.'); });
  $('#buildClosing').addEventListener('click', buildClosing);
  $('#buildFunding1').addEventListener('click', buildFunding1);
  $('#buildClientPkg').addEventListener('click', buildClientPkg);
  $('#zipFD2').addEventListener('click', downloadFD2Zip);

  // Drag & drop folder support (Chrome-based)
  window.addEventListener('dragover', e=>{ e.preventDefault(); });
  window.addEventListener('drop', e=>{
    e.preventDefault();
    const items = e.dataTransfer.items;
    if(!items) return;
    // Traverse directories
    const entries = [];
    for(const it of items){ const entry = it.webkitGetAsEntry?.(); if(entry) entries.push(entry); }
    const promises = entries.map(entry => new Promise(res=>{
      const acc = [];
      const walk = (ent, path='')=>{
        if(ent.isFile){ ent.file(f=>{ f.webkitRelativePath = path + f.name; acc.push(f); }, ()=>{}); }
        else if(ent.isDirectory){ const reader = ent.createReader(); reader.readEntries(ents=>{ ents.forEach(ch=> walk(ch, path + ent.name + '/')); }, ()=>{}); }
      };
      walk(entry); setTimeout(()=> res(acc), 300); // small delay to gather
    }));
    Promise.all(promises).then(groups=>{ const all = groups.flat(); indexFiles(all); renderSlots(listCandidates()); });
  });
  </script>
</body>
</html>
